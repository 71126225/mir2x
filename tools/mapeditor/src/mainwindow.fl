# data file for the Fltk User Interface Designer (fluid)
version 1.0304
header_name {.hpp}
code_name {.cpp}
decl {\#include <map>} {private local
}

decl {\#include <array>} {private local
}

decl {\#include <string>} {private local
}

decl {\#include <ctime>} {private local
}

decl {\#include <vector>} {public local
}

decl {\#include <cstdint>} {private local
}

decl {\#include <optional>} {private local
}

decl {\#include <cstring>} {private local
}

decl {\#include <FL/fl_draw.H>} {public local
}

decl {\#include "datef.hpp"} {public local
}

decl {\#include <FL/Fl_Shared_Image.H>} {public local
}

decl {\#include "filesys.hpp"} {private local
}

decl {\#include "strf.hpp"} {private local
}

decl {\#include "totype.hpp"} {private local
}

decl {\#include "pngf.hpp"} {private local
}

decl {\#include "imagedb.hpp"} {private local
}

decl {\#include "drawarea.hpp"} {public global
}

decl {\#include "mathf.hpp"} {private local
}

decl {\#include "colorf.hpp"} {private local
}

decl {\#include "hexstr.hpp"} {private local
}

decl {\#include "editormap.hpp"} {private local
}

decl {\#include "imagecache.hpp"} {private local
}

decl {\#include "animationdraw.hpp"} {private local
}

decl {\#include "animationselectwindow.hpp"} {private local
}

decl {\#include <FL/Fl_Native_File_Chooser.H>} {public local
}

class MainWindow {} {
  decl {std::string m_wilFilePathName} {private local
  }
  Function {MainWindow()} {} {
    Fl_Window m_window {
      label {mapeditor-version-0.0.1}
      callback {{
	switch(fl_choice("Quit map editor?", nullptr, " No", " Yes ")){
		case 2  : exit(0); break;
		default :          break;
	}
}}
      xywh {140 255 985 690} type Double resizable visible
    } {
      Fl_Box m_drawArea {
        xywh {0 20 965 627} labelfont 4 resizable
        class DrawArea
      }
      Fl_Menu_Bar m_menuBar {
        xywh {0 0 993 20} box THIN_UP_BOX labelfont 4 textfont 4
      } {
        Submenu {} {
          label Project
          xywh {0 0 62 20} labelfont 4
        } {
          MenuItem {} {
            label New
            callback {SetWorkingPathName();
fl_alert("%s", "Haven't implement yet!");}
            xywh {0 0 30 20} labelfont 4 divider
          }
          MenuItem {} {
            label {Load Mir2Map}
            callback {{
    // maybe default or setted one, depends
    MakeWorkingFolder();

    extern std::string g_wilFilePathName;
    if(g_wilFilePathName == ""){
        SetWilFilePathName();
    }

    if(g_wilFilePathName != ""){
        LoadMir2Map();
    }
}}
            xywh {0 0 30 20} labelfont 4
            code0 {\#include <string>}
            code1 {\#include <FL/Fl_Native_File_Chooser.H>}
            code2 {\#include <FL/fl_ask.H>}
            code3 {\#include <algorithm>}
          }
          MenuItem {} {
            label {Load Mir2xMapData}
            callback {{
    extern std::string g_wilFilePathName;
    if(g_wilFilePathName == ""){
        SetWilFilePathName();
    }

    Fl_Native_File_Chooser stFileChooser;
    stFileChooser.title("Set Map File Path...");
    stFileChooser.options(Fl_Native_File_Chooser::NO_OPTIONS);
    stFileChooser.type(Fl_Native_File_Chooser::BROWSE_DIRECTORY);

    stFileChooser.directory(".");

    switch(stFileChooser.show()){
        case -1:
            {
                fl_alert("%s", stFileChooser.errmsg());
                break;
            }
        case 1:
            {
                break;
            }
        default:
            {
                extern std::string g_workingPathName;
                g_workingPathName = "";
                MakeWorkingFolder();

                std::string szPath = stFileChooser.filename();
                std::replace(szPath.begin(), szPath.end(), '\\\\', '/');

                if(szPath.back() == '/'){
                    szPath += "DESC.BIN";
                }else{
                    szPath += "/DESC.BIN";
                }

                if(filesys::hasFile(szPath.c_str())){
                    extern EditorMap g_editorMap;
                    if(!g_editorMap.LoadMir2xMapData(szPath.c_str()) || !g_editorMap.Valid()){
                        fl_alert("Failed to load Mir2xMapData: %s", szPath.c_str());
                    }

                    setFootLog(str_printf("Mir2xMapData %s, width %zu, height %zu", szPath.c_str(), to_uz(g_editorMap.W()), to_uz(g_editorMap.H())).c_str());
                    AfterLoadMap();
                    Fl::remove_timeout(UpdateFrame);
                    Fl::add_timeout(0.1, UpdateFrame);

                }else{
                    fl_alert("Invalid Mir2xMapData folder: %s", szPath.c_str());
                }
            }
    }
}}
            xywh {10 10 30 20} shortcut 0x4006f labelfont 4 divider
            code0 {\#include <string>}
            code1 {\#include "editormap.hpp"}
          }
          MenuItem {} {
            label {Save Mir2xMapData}
            callback {{
    SaveMir2xMapData();
}}
            xywh {10 10 30 20} labelfont 4 divider
          }
          MenuItem {} {
            label {Export Overview 1:1}
            callback {{
    extractOverview(1);
}}
            xywh {20 20 30 20} labelfont 4
          }
          MenuItem {} {
            label {Export Overview 1:2}
            callback {{
    extractOverview(2);
}}
            xywh {30 30 30 20} labelfont 4
          }
          MenuItem {} {
            label {Export Overview 1:4}
            callback {{
    extractOverview(4);
}}
            xywh {40 40 30 20} labelfont 4
          }
          MenuItem {} {
            label {Export Overview 1:8}
            callback {{
    extractOverview(8);
}}
            xywh {50 50 30 20} labelfont 4
          }
          MenuItem {} {
            label {Export Overview 1:16}
            callback {{
    extractOverview(16);
}}
            xywh {60 60 30 20} labelfont 4
          }
          MenuItem {} {
            label {Export Overview 1:32}
            callback {{
    extractOverview(32);
}}
            xywh {70 70 30 20} labelfont 4 divider
          }
          MenuItem {} {
            label {Save As}
            callback {{
	// automatically generate another working folder
	// and setting current working folder to it
}}
            xywh {0 0 30 20} shortcut 0x50073 labelfont 4 divider
          }
          MenuItem {} {
            label Quit
            callback {exit(0);}
            xywh {0 0 30 20} shortcut 0x40071 labelfont 4
          }
        }
        Submenu {} {
          label Grid
          xywh {0 0 62 20} labelfont 4
        } {
          MenuItem m_menuItemGridLine {
            label {Step                  }
            xywh {30 30 30 20} type Toggle labelfont 4
          }
          MenuItem m_menuItemAttributeGridLine {
            label Attribute
            callback {{
	extern AttributeSelectWindow *g_attributeGridWindow;
	if(m_menuItemAttributeGridLine->value()){
		g_attributeGridWindow->ShowAll();
	}
}}
            xywh {30 30 30 20} type Toggle labelfont 4 divider
          }
          MenuItem m_menuItemLightLine {
            label Light
            xywh {0 0 30 20} type Toggle labelfont 4
          }
          MenuItem m_menuItemBaseTileLine {
            label Tile
            xywh {10 10 30 20} type Toggle labelfont 4
          }
          MenuItem m_menuItemGroundObjectLine {
            label {Ground Object}
            xywh {10 10 30 20} type Toggle labelfont 4
          }
          MenuItem m_menuItemOverGroundObjectLine {
            label {Over Ground Object}
            xywh {20 20 30 20} type Toggle labelfont 4
          }
        }
        Submenu {} {
          label Show
          xywh {10 10 62 20} labelfont 4
        } {
          MenuItem m_menuItemShowLight {
            label Light
            xywh {10 10 30 20} type Toggle value 1 labelfont 4
          }
          MenuItem m_menuItemShowTile {
            label Tile
            xywh {20 20 30 20} type Toggle value 1 labelfont 4
          }
          MenuItem m_menuItemShowGroundObject {
            label {Ground Object     }
            xywh {20 20 30 20} type Toggle value 1 labelfont 4
          }
          MenuItem m_menuItemShowOverGroundObject {
            label {Over Ground Object          }
            xywh {30 30 30 20} type Toggle value 1 labelfont 4 divider
          }
          MenuItem m_menuItemClearBackground {
            label {Clear Background         }
            xywh {40 40 30 20} type Toggle value 1 labelfont 4
          }
        }
        Submenu {} {
          label Edit
          xywh {20 20 62 20} labelfont 4
        } {
          MenuItem m_menuItemEnableEdit {
            label {Enable Edit                    }
            xywh {20 20 30 20} type Toggle labelfont 4
          }
          MenuItem m_menuItemEditGround {
            label {Edit Ground Info}
            xywh {30 30 30 20} type Toggle labelfont 4 divider
          }
          MenuItem {} {
            label Optimize
            callback {{
    extern EditorMap g_editorMap;
        if(g_editorMap.Valid()){
        g_editorMap.Optimize();
    }
}}
            xywh {40 40 30 20} labelfont 4
            code0 {\#include "editormap.hpp"}
          }
          MenuItem {} {
            label Resize
            callback {{
    extern CropConfigureWindow *g_cropConfigureWindow;
    g_cropConfigureWindow->ShowAll();
}}
            xywh {50 50 30 20} labelfont 4
            code0 {\#include "cropconfigurewindow.hpp"}
          }
        }
        Submenu {} {
          label Select
          xywh {0 0 62 20} labelfont 4
        } {
          MenuItem m_menuItemEnableSelect {
            label {Enable Select         }
            xywh {30 30 30 20} type Toggle labelfont 4 divider
          }
          MenuItem m_menuItemSelectBySingle {
            label Single
            xywh {50 50 30 20} type Radio value 1 labelfont 4
          }
          MenuItem m_menuItemSelectByRhombus {
            label Rhombus
            xywh {60 60 30 20} type Radio labelfont 4
          }
          MenuItem m_menuItemSelectByRectangle {
            label Rectangle
            xywh {70 70 30 20} type Radio labelfont 4 divider
          }
          MenuItem m_menuItemSelectByAttribute {
            label Attribute
            callback {{
	extern AttributeSelectWindow *g_attributeSelectWindow;
	if(m_menuItemSelectByAttribute->value()){
		g_attributeSelectWindow->ShowAll();
	}
}}
            xywh {30 30 30 20} type Radio value 1 labelfont 4
            code0 {\#include "attributeselectwindow.hpp"}
          }
          MenuItem m_menuItemSelectByTile {
            label Tile
            xywh {40 40 30 20} type Radio labelfont 4
          }
          MenuItem m_menuItemSelectByObjectGround {
            label {Ground Object}
            xywh {50 50 30 20} type Radio labelfont 4
          }
          MenuItem m_menuItemSelectByObjectOverGround {
            label {Over Ground Object}
            xywh {60 60 30 20} type Radio labelfont 4 divider
          }
          MenuItem m_menuItemReversed {
            label Reversed
            xywh {10 10 30 20} type Toggle labelfont 4
          }
          MenuItem m_menuItemDeselect {
            label Deselect
            xywh {20 20 30 20} type Toggle labelfont 4 divider
          }
          MenuItem {} {
            label Settings
            callback {extern SelectSettingWindow *g_selectSettingWindow;

if(g_selectSettingWindow){
	g_selectSettingWindow->ShowAll();
}}
            xywh {30 30 30 20} labelfont 4
            code0 {\#include "selectsettingwindow.hpp"}
          }
        }
        Submenu {} {
          label Layer
          xywh {0 0 70 20} labelfont 4
        } {
          MenuItem {} {
            label {Import Layer           }
            xywh {40 40 30 20} labelfont 4
            code0 {\#include "layerbrowserwindow.hpp"}
          }
          MenuItem {} {
            label {Export Layer}
            callback {{
    // show the layer browser window
    // it may or may not hide when click it
    extern LayerBrowserWindow *g_layerBrowserWindow;
    g_layerBrowserWindow->ShowAll();
}}
            xywh {50 50 30 20} labelfont 4 divider
            code0 {\#include "layerbrowserwindow.hpp"}
          }
          MenuItem {} {
            label Reject
            xywh {50 50 30 20} type Radio value 1 labelfont 4
            code0 {\#include "layerbrowserwindow.hpp"}
          }
          MenuItem {} {
            label Replace
            xywh {60 60 30 20} type Radio labelfont 4
            code0 {\#include "layerbrowserwindow.hpp"}
          }
          MenuItem {} {
            label Substitute
            xywh {70 70 30 20} type Radio labelfont 4 divider
            code0 {\#include "layerbrowserwindow.hpp"}
          }
          MenuItem {} {
            label {Layer Browser}
            callback {{
    // show the layer browser window
    // it may or may not hide when click it
    extern LayerBrowserWindow *g_layerBrowserWindow;
    g_layerBrowserWindow->ShowAll();
}}
            xywh {30 30 30 20} labelfont 4
            code0 {\#include "layerbrowserwindow.hpp"}
          }
        }
        Submenu {} {
          label Test
          xywh {0 0 70 20}
        } {
          MenuItem m_menuItemEnableTest {
            label {Enable Test                }
            callback {{
    CenterAnimation();
}}
            xywh {0 0 34 20} type Toggle divider
          }
          MenuItem {} {
            label {Animation DB}
            callback {{
    // set test animation db here
    Fl_Native_File_Chooser stFileChooser;
    stFileChooser.title("Set Test Animation Database Path...");
    stFileChooser.options(Fl_Native_File_Chooser::NO_OPTIONS);
    stFileChooser.type(Fl_Native_File_Chooser::BROWSE_DIRECTORY);

    stFileChooser.directory(".");

    switch(stFileChooser.show()){
        case -1:
            {
                fl_alert("%s", stFileChooser.errmsg());
                break;
            }
        case 1:
            {
                break;
            }
        default:
            {
                std::string szChooseDBPath = stFileChooser.filename();
                std::replace(szChooseDBPath.begin(), szChooseDBPath.end(), '\\\\', '/');

                extern AnimationDB g_animationDB;
                if(!g_animationDB.Load(szChooseDBPath.c_str())){
                    fl_alert("%s", "Load test animation database failed");
                }

                extern AnimationSelectWindow *g_animationSelectWindow;
                g_animationSelectWindow->Load();
                g_animationSelectWindow->ShowAll();

                break;
            }
    }
}}
            xywh {0 0 34 20} labelfont 4
            code0 {\#include "animationdb.hpp"}
          }
          MenuItem {} {
            label {Animation Configuration      }
            callback {{
    extern AnimationSelectWindow *g_animationSelectWindow;
    g_animationSelectWindow->ShowAll();
}}
            xywh {10 10 34 20} labelfont 4
          }
        }
        Submenu {} {
          label About
          xywh {30 30 62 20} labelfont 4
        } {
          MenuItem {} {
            label {About Me               }
            callback {extern AboutWindow *g_aboutWindow;
g_aboutWindow->ShowAll();}
            xywh {30 30 30 20} labelfont 4
            code0 {\#include "aboutwindow.hpp"}
          }
        }
      }
      Fl_Scrollbar m_vsbar {
        callback {auto pWidget = ((Fl_Valuator *)(m_vsbar));
auto fValue  = pWidget->value();

extern EditorMap g_editorMap;
if(g_editorMap.Valid()){
	int nValidYOffset = g_editorMap.H() * SYS_MAPGRIDYP - m_drawArea->h();
	nValidYOffset = (std::max<int>)(0, nValidYOffset);
	int nYOffset = to_d(nValidYOffset * fValue * 1.0);
    	m_drawArea->SetOffset(0, true, nYOffset, false);
	m_window->redraw();
}}
        xywh {965 20 20 647} labelfont 4 step 0.001 deactivate
        code0 {\#include "editormap.hpp"}
      }
      Fl_Scrollbar m_hsbar {
        callback {auto pWidget = ((Fl_Valuator *)(m_hsbar));
auto fValue  = pWidget->value();

extern EditorMap g_editorMap;
if(g_editorMap.Valid()){
	int nValidXOffset = g_editorMap.W() * SYS_MAPGRIDXP - m_drawArea->w();
	nValidXOffset = (std::max<int>)(0, nValidXOffset);
	int nXOffset = to_d(nValidXOffset * fValue * 1.0);
    	m_drawArea->SetOffset(nXOffset, false, 0, true);
	m_window->redraw();
}}
        xywh {0 647 965 20} type Horizontal labelfont 4 step 0.001 deactivate
        code0 {\#include "editormap.hpp"}
      }
      Fl_Box m_logBar {
        label label
        private xywh {0 667 985 25} box THIN_UP_BOX labelfont 4 align 20
      }
    }
    code {{
    // set slider size
    // current the fluid can set the slider_size
    // but when parsing it, it complains ``unknown property: slider_size"

    setScrollBarSize(1.0, 1.0);
    setFootLog("no map loaded");
}} {}
  }
  Function {ShowAll()} {return_type void
  } {
    code {{
	m_window->show();
}} {}
  }
  Function {RedrawAll()} {return_type void
  } {
    code {{
	m_window->redraw();
}} {}
  }
  Function {LoadMir2MapImage()} {return_type void
  } {
    code {{
    extern std::string g_wilFilePathName;
    extern ImageDB    *g_imageDB;
    if(!g_imageDB){
        g_imageDB = new ImageDB(g_wilFilePathName.c_str());
    }
}} {}
  }
  Function {LoadMir2Map()} {return_type void
  } {
    code {{
    extern EditorMap g_editorMap;

    Fl_Native_File_Chooser fileChooser;
    fileChooser.title("Select .map file");
    fileChooser.type(Fl_Native_File_Chooser::BROWSE_FILE);

    char matchedFileNames[] =
        "MAP\\t*.map\\n"
        ;

    fileChooser.filter(matchedFileNames);
    fileChooser.directory(".");
    switch(fileChooser.show()){
        case -1:
            fl_alert("%s", fileChooser.errmsg());
            break;
        case  1:
            break;
        default:
            {
                if(!g_editorMap.LoadMir2Map(fileChooser.filename())){
                    fl_alert("Load mir2 map %s failed", fileChooser.filename());
                }

                setFootLog(str_printf("Mir2Map %s, width %zu, height %zu", fileChooser.filename(), to_zu(g_editorMap.W()), to_zu(g_editorMap.H())).c_str());
                AfterLoadMap();

                Fl::remove_timeout(UpdateFrame);
                Fl::add_timeout(0.1, UpdateFrame);
            }
            break;
    }
    m_drawArea->redraw();
}} {}
  }
  Function {AfterLoadMap()} {return_type void
  } {
    code {{
    // should reset the offset
    // no matter editor map valid or not
    setScrollBarValue(0.0, 0.0);
    m_drawArea->SetOffset(0, false, 0, false);

    // check if we need to deactivate the scroll bars
    // 1. used after load map
    // 2. used after draw area resize
    checkScrollBar();
    RedrawAll();
}} {}
  }
  Function {SetWorkingPathName()} {return_type void
  } {
    code {{
    // set the work folder
    // default CACHE system locates inside
    extern std::string g_workingPathName;
    Fl_Native_File_Chooser stFileChooser;

    stFileChooser.title("Set Working Folder...");
    stFileChooser.options(Fl_Native_File_Chooser::NO_OPTIONS);
    stFileChooser.type(Fl_Native_File_Chooser::BROWSE_DIRECTORY);

    stFileChooser.directory(".");

    switch(stFileChooser.show()){
        case -1:
            {
                fl_alert("%s", stFileChooser.errmsg());
                break;
            }
        case 1:
            {
                break;
            }
        default:
            {
                g_workingPathName = stFileChooser.filename();
                std::replace(g_workingPathName.begin(), g_workingPathName.end(), '\\\\', '/');
                while(!g_workingPathName.empty() && g_workingPathName.back() == '/'){
                    g_workingPathName.pop_back();
                }
                MakeWorkingFolder();
            }
            break;
    }
}} {}
  }
  Function {SetWilFilePathName()} {return_type void
  } {
    code {{
    extern std::string g_wilFilePathName;
    Fl_Native_File_Chooser stFileChooser;
    stFileChooser.title("Set *.wil File Path...");
    stFileChooser.options(Fl_Native_File_Chooser::NO_OPTIONS);
    stFileChooser.type(Fl_Native_File_Chooser::BROWSE_DIRECTORY);

    stFileChooser.directory(".");

    switch(stFileChooser.show()){
        case -1:
            {
                fl_alert("%s", stFileChooser.errmsg());
                break;
            }
        case 1:
            {
                break;
            }
        default:
            {
                std::string szOldWilFilePathName = g_wilFilePathName;
                g_wilFilePathName = stFileChooser.filename();
                std::replace(g_wilFilePathName.begin(), g_wilFilePathName.end(), '\\\\', '/');
                if(szOldWilFilePathName != g_wilFilePathName){
                    LoadMir2MapImage();
                    break;
                }
            }
    }
}} {}
  }
  Function {UpdateFrame(void *)} {return_type {static void}
  } {
    code {{
    extern EditorMap g_editorMap;
    if(g_editorMap.Valid()){
        g_editorMap.UpdateFrame(50);
        extern MainWindow *g_mainWindow;
        g_mainWindow->RedrawAll();
    }
    Fl::repeat_timeout(0.1, UpdateFrame);
}} {}
  }
  Function {UpdateAnimationFrame(void *)} {return_type {static void}
  } {
    code {{
    extern EditorMap g_editorMap;
    extern MainWindow *g_mainWindow;
    extern AnimationDB g_animationDB;
    extern AnimationDraw g_animationDraw;

    if(g_editorMap.Valid() && g_animationDraw.MonsterID){
        auto &rstRecord = g_animationDB.RetrieveAnimation(g_animationDraw.MonsterID);
        if(rstRecord.Valid() && rstRecord.DirectionValid(g_animationDraw.Action, g_animationDraw.Direction)){
            if(rstRecord.FrameValid(g_animationDraw.Action, g_animationDraw.Direction, g_animationDraw.Frame + 1, true) && rstRecord.FrameValid(g_animationDraw.Action, g_animationDraw.Direction, g_animationDraw.Frame + 1, false)){
                g_animationDraw.Frame = g_animationDraw.Frame + 1;
            }else{
                g_animationDraw.Frame = 0;
            }

            Fl::repeat_timeout(0.1, UpdateAnimationFrame);
            g_mainWindow->RedrawAll();
            return;
        }
    }

    Fl::remove_timeout(UpdateAnimationFrame);
    g_mainWindow->RedrawAll();
}} {}
  }
  Function {ShowTileLine()} {return_type bool
  } {
    code {{
	return m_menuItemBaseTileLine->value();
}} {}
  }
  Function {ShowGroundObjectLine()} {return_type bool
  } {
    code {{
	return m_menuItemGroundObjectLine->value();
}} {}
  }
  Function {ShowOverGroundObjectLine()} {return_type bool
  } {
    code {{
	return m_menuItemOverGroundObjectLine->value();
}} {}
  }
  Function {ShowLightLine()} {return_type bool
  } {
    code {{
	return m_menuItemLightLine->value();
}} {}
  }
  Function {ShowGridLine()} {return_type bool
  } {
    code {{
	return m_menuItemGridLine->value();
}} {}
  }
  Function {ShowAttributeGridLine()} {return_type bool
  } {
    code {{
	return m_menuItemAttributeGridLine->value();
}} {}
  }
  Function {ShowLight()} {return_type bool
  } {
    code {{
	return m_menuItemShowLight->value();
}} {}
  }
  Function {ShowTile()} {return_type bool
  } {
    code {{
	return m_menuItemShowTile->value();
}} {}
  }
  Function {ShowObject(bool bGround)} {return_type bool
  } {
    code {{
    if(bGround){
        return m_menuItemShowGroundObject->value();
    }else{
        return m_menuItemShowOverGroundObject->value();
    }
}} {}
  }
  Function {EnableEdit()} {return_type bool
  } {
    code {{
	return m_menuItemEnableEdit->value();
}} {}
  }
  Function {EnableSelect()} {return_type bool
  } {
    code {{
	return m_menuItemEnableSelect->value();
}} {}
  }
  Function {EnableTest()} {return_type bool
  } {
    code {{
    return m_menuItemEnableTest->value();
}} {}
  }
  Function {SelectByAttribute()} {return_type bool
  } {
    code {{
	return m_menuItemSelectByAttribute->value();
}} {}
  }
  Function {SelectByRhombus()} {return_type bool
  } {
    code {{
	return m_menuItemSelectByRhombus->value();
}} {}
  }
  Function {SelectByRectangle()} {return_type bool
  } {
    code {{
	return m_menuItemSelectByRectangle->value();
}} {}
  }
  Function {SelectBySingle()} {return_type bool
  } {
    code {{
	return m_menuItemSelectBySingle->value();
}} {}
  }
  Function {SelectByTile()} {return_type bool
  } {
    code {{
	return m_menuItemSelectByTile->value();
}} {}
  }
  Function {SelectByObject(bool bGround)} {return_type bool
  } {
    code {{
    if(bGround){
        return m_menuItemSelectByObjectGround->value();
    }else{
        return m_menuItemSelectByObjectOverGround->value();
    }
}} {}
  }
  Function {MakeWorkingFolder()} {return_type void
  } {
    code {{
    extern std::string g_workingPathName;
    if(g_workingPathName == "" || (g_workingPathName.size() > 0 && g_workingPathName[0] == '.')){
        g_workingPathName = std::string("./") + datef::now();
    }

    filesys::removeDir(g_workingPathName.c_str());
    filesys::makeDir(g_workingPathName.c_str());
}} {}
  }
  Function {SaveMir2xMapData()} {return_type void
  } {
    code {{
	extern EditorMap g_editorMap;
	if(g_editorMap.Valid()){
		extern std::string g_workingPathName;
    		std::string szTmpFileName = g_workingPathName;
	
		if(szTmpFileName.back() == '/'){
        		szTmpFileName += "DESC.BIN";
    		}else{
        		szTmpFileName += "/DESC.BIN";
    		}
    		g_editorMap.SaveMir2xMapData(szTmpFileName.c_str());
    		fl_message("Save map file in mir2xmapdata format successfully!");
    		
	}else{
		fl_alert("%s", "Currently no operating map!");
	}
}} {}
  }
  Function {ClearBackground()} {return_type bool
  } {
    code {{
    return m_menuItemClearBackground->value();
}} {}
  }
  Function {Deselect()} {return_type bool
  } {
    code {{
    return m_menuItemDeselect->value();
}} {}
  }
  Function {Reversed()} {return_type bool
  } {
    code {{
    return m_menuItemReversed->value();
}} {}
  }
  Function {CenterAnimation()} {return_type void
  } {
    code {{
    extern AnimationDraw g_animationDraw;
    if(g_animationDraw.MonsterID){
        int nX = m_drawArea->OffsetX() + m_window->w() / 2;
        int nY = m_drawArea->OffsetY() + m_window->h() / 2;

        g_animationDraw.X = nX;
        g_animationDraw.Y = nY;
    }
}} {}
  }
  Function {checkScrollBar()} {return_type void
  } {
    code {{
    // check if we need to deactivate the scroll bars
    // 1. used after load map
    // 2. used after draw area resize
    extern EditorMap g_editorMap;
    if(g_editorMap.Valid()){
        if(g_editorMap.W() * SYS_MAPGRIDXP <= m_drawArea->w()){
            m_hsbar->deactivate();
            setHScrollBarValue(0.0);
        }else{
            m_hsbar->activate();
        }

        if(g_editorMap.H() * SYS_MAPGRIDYP <= m_drawArea->h()){
            m_vsbar->deactivate();
            setVScrollBarValue(0.0);
        }else{
            m_vsbar->activate();
        }
    }
    else{
        m_hsbar->deactivate();
        m_vsbar->deactivate();

        ((Fl_Valuator *)(m_hsbar))->value(0.0);
        ((Fl_Valuator *)(m_vsbar))->value(0.0);

        ((Fl_Slider *)(m_hsbar))->slider_size(1.0);
        ((Fl_Slider *)(m_vsbar))->slider_size(1.0);
    }
}} {}
  }
  Function {setScrollBarValue(std::optional<double> fXP, std::optional<double> fYP)} {return_type void
  } {
    code {{
    if(fXP.has_value()) setHScrollBarValue(fXP.value());
    if(fYP.has_value()) setVScrollBarValue(fYP.value());
}} {}
  }
  Function {setHScrollBarValue(double fXP)} {return_type void
  } {
    code {{
	auto pWidgetX = ((Fl_Valuator *)(m_hsbar));
	fXP = (std::min<double>)(1.0, (std::max<double>)(0.0, fXP));
	pWidgetX->value(pWidgetX->round(fXP));
}} {}
  }
  Function {setVScrollBarValue(double fYP)} {return_type void
  } {
    code {{
	auto pWidgetY = ((Fl_Valuator *)(m_vsbar));
	fYP = (std::min<double>)(1.0, (std::max<double>)(0.0, fYP));
	pWidgetY->value(pWidgetY->round(fYP));
}} {}
  }
  Function {Activate()} {return_type void
  } {
    code {{
    m_hsbar->activate();
    m_vsbar->activate();
    m_menuBar->activate();
}} {}
  }
  Function {Deactivate()} {return_type void
  } {
    code {{
    m_hsbar->deactivate();
    m_vsbar->deactivate();
    m_menuBar->deactivate();
}} {}
  }
  Function {extractOverview(int overviewRatio)} {return_type void
  } {
    code {{
    // create a big png file as an overview of the current map
    // generate name and save it in current working folder, support ratio 1/2/4/8/16

    switch(overviewRatio){
        case 1:
        case 2:
        case 4:
        case 8:
        case 16:
        case 32:
            {
                break;
            }
        default:
            {
                fl_alert("Overview ratio is not supported: %d", overviewRatio);
                return;
            }
    }

    extern EditorMap g_editorMap;
    if(!g_editorMap.Valid()){
        fl_alert("Current editor map is invalid");
        return;
    }

    extern std::string g_workingPathName;
    if(g_workingPathName == ""){
        fl_alert("Current editor working path is invalid");
        return;
    }

    const int nDstW = g_editorMap.W() * SYS_MAPGRIDXP;
    const int nDstH = g_editorMap.H() * SYS_MAPGRIDYP;

    if(nDstW % overviewRatio || nDstH % overviewRatio){
        fl_alert("system error: overview ratio can't devide original map pixel size");
        return;
    }

    std::vector<uint32_t> stvBuf(nDstW * nDstH, 0);
    auto pDst = &(stvBuf[0]);

    auto fnBufDraw = [](
            uint32_t       *pDst, int nDstW, int nDstH,
            const uint32_t *pSrc, int nSrcW, int nSrcH,

            int nOnDstX, int nOnDstY,
            int nOnSrcX, int nOnSrcY,
            int nOnSrcW, int nOnSrcH)
    {
        if(true
                && pDst
                && nDstW > 0
                && nDstH > 0

                && pSrc
                && nSrcW > 0
                && nSrcH > 0){

            auto nOldOnSrcX = nOnSrcX;
            auto nOldOnSrcY = nOnSrcY;

            if(true
                    && nOnSrcW > 0
                    && nOnSrcH > 0
                    && mathf::rectangleOverlapRegion<int>(0, 0, nSrcW, nSrcH, &nOnSrcX, &nOnSrcY, &nOnSrcW, &nOnSrcH)){

                nOnDstX += (nOnSrcX - nOldOnSrcX);
                nOnDstY += (nOnSrcY - nOldOnSrcY);

                auto nOldOnDstX = nOnDstX;
                auto nOldOnDstY = nOnDstY;

                if(true
                        && nOnSrcW > 0
                        && nOnSrcH > 0
                        && mathf::rectangleOverlapRegion<int>(0, 0, nDstW, nDstH, &nOnDstX, &nOnDstY, &nOnSrcW, &nOnSrcH)){

                    nOnSrcX += (nOnDstX - nOldOnDstX);
                    nOnSrcY += (nOnDstY - nOldOnDstY);

                    if(true
                            && nOnSrcW > 0
                            && nOnSrcH > 0){

                        for(int nOnSrcDX = 0; nOnSrcDX < nOnSrcW; ++nOnSrcDX){
                            for(int nOnSrcDY = 0; nOnSrcDY < nOnSrcH; ++nOnSrcDY){
                                auto &nSrc = pSrc[(nOnSrcX + nOnSrcDX) + (nOnSrcY + nOnSrcDY) * nSrcW];
                                auto &nDst = pDst[(nOnDstX + nOnSrcDX) + (nOnDstY + nOnSrcDY) * nDstW];
                                nDst = colorf::renderABGR(nDst, nSrc);
                            }
                        }
                    }
                }
            }
        }
    };

    auto fnBufDrawImage = [this, fnBufDraw, pDst, nDstW, nDstH](uint8_t nFileIndex, uint16_t nImageIndex, int nX, int nY, bool bObj)
    {
        extern ImageDB *g_imageDB;
        extern EditorMap g_editorMap;

        if(true
                && g_editorMap.ValidC(nX, nY)
                && g_imageDB->setIndex(nFileIndex, nImageIndex)){

            if(const auto [pSrc, nSrcW, nSrcH] = g_imageDB->decode(nFileIndex, nImageIndex, 0XFFFFFFFF, 0XFFFFFFFF, 0XFFFFFFFF); pSrc){
                fnBufDraw(
                        pDst, nDstW, nDstH,
                        pSrc, nSrcW, nSrcH,

                        nX * SYS_MAPGRIDXP,
                        nY * SYS_MAPGRIDYP + (bObj ? (SYS_MAPGRIDYP - nSrcH) : 0),

                        0,
                        0,

                        nSrcW,
                        nSrcH);
            }
        }
    };

    g_editorMap.ExportOverview(fnBufDrawImage);
    const std::string szOverviewFileName = datef::now() + ".PNG";
    const std::string szOverviewFullFileName = g_workingPathName + "/" + szOverviewFileName;

    int exportW = nDstW;
    int exportH = nDstH;
    const uint32_t *exportBufPtr = pDst;

    std::vector<uint32_t> overviewBuf;
    if(overviewRatio != 1){
        const int overviewW = nDstW / overviewRatio;
        const int overviewH = nDstH / overviewRatio;

        overviewBuf.resize(overviewW * overviewH, 0);
        for(int y = 0; y < overviewH; ++y){
            for(int x = 0; x < overviewW; ++x){
                const int origX = x * overviewRatio;
                const int origY = y * overviewRatio;
                overviewBuf[y * overviewW + x] = stvBuf[origY * nDstW + origX];
            }
        }

        exportW = overviewW;
        exportH = overviewH;
        exportBufPtr = overviewBuf.data();
    }

    if(pngf::saveRGBABuffer((const uint8_t *)(exportBufPtr), to_u32(exportW), to_u32(exportH), szOverviewFullFileName.c_str())){
        fl_alert("Done overview map image: %s", szOverviewFileName.c_str());
    }
    else{
        fl_alert("Export overview map image failed");
    }
}} {}
  }
  Function {setFootLog(const char *msg)} {return_type void
  } {
    code {{
    if(str_haschar(msg)){
        m_logBar->copy_label(str_printf("[STATUS]: %s", msg).c_str());
    }
    else{
        m_logBar->copy_label("[STATUS]");
    }

    m_logBar->redraw();
    m_window->redraw();
}} {}
  }
  Function {setScrollBarSize(std::optional<float> vslider, std::optional<float> hslider)} {return_type void
  } {
    code {{
    if(vslider.has_value() && vslider.value() >= 0.0 && vslider.value() <= 1.0){
        ((Fl_Slider *)(m_vsbar))->slider_size(vslider.value());
    }

    if(hslider.has_value() && hslider.value() >= 0.0 && hslider.value() <= 1.0){
        ((Fl_Slider *)(m_hsbar))->slider_size(hslider.value());
    }

    m_window->redraw();
}} {}
  }
}
