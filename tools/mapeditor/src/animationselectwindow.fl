# data file for the Fltk User Interface Designer (fluid)
version 1.0304
header_name {.hpp}
code_name {.cpp}
decl {\#include <cmath>} {selected public global
}

decl {\#include <cstdint>} {public global
}

decl {\#include <algorithm>} {public global
}

decl {\#include "animationdb.hpp"} {private local
}

decl {\#include "totype.hpp"} {private local
}

class AnimationSelectWindow {open
} {
  decl {uint32_t m_frame;} {private local
  }
  Function {AnimationSelectWindow()} {open
  } {
    code {m_frame = -1; // to pointer to first frame
              // this variable will be updated by time callback functioin
              // we don't have m_action and m_direction since it can be read from the browser->selected(i)} {}
    Fl_Window m_window {open
      xywh {831 350 650 500} type Double non_modal visible
    } {
      Fl_Browser m_browserAnimation {
        callback {{
    // if(!Fl::event_clicks()){
    //     return;
    // }
    
    // every time when we get a click, we clear the action & direction
    // even if this click is null
    m_browserAction->clear();
    m_browserDirection->clear();
    
    uint32_t nMonsterID = MonsterID();
    if(nMonsterID){
        extern AnimationDB g_animationDB;
        for(uint32_t nAction = 0; nAction < 16; ++nAction){
            if(g_animationDB.RetrieveAnimation(nMonsterID).ActionValid(nAction)){
                char szAction[64];
                std::sprintf(szAction, "Action: %02d", nAction);
                m_browserAction->add(szAction, (void *)(uintptr_t)(nAction));
            }
        }   
    }
        
    RedrawAll();
}}
        xywh {0 0 300 500} type Hold labelfont 4 textfont 4
      }
      Fl_Box m_animationPreviewArea {
        xywh {300 0 350 280} box UP_BOX labelfont 4
        code0 {\#include "animationpreviewarea.hpp"}
        class AnimationPreviewArea
      }
      Fl_Browser m_browserAction {
        callback {{
    // if(!Fl::event_clicks()){
    //     return;
    // }
    m_browserDirection->clear();
    
    uint32_t nMonsterID = MonsterID();
    if(nMonsterID){
        // we do have a valid monster id
        int nAction0 = Action();
        if(nAction0 >= 0){
            uint32_t nAction = to_u32(nAction0);
            for(uint32_t nDirection = 0; nDirection < 8; ++nDirection){
                extern AnimationDB g_animationDB;
                if(g_animationDB.RetrieveAnimation(nMonsterID).DirectionValid(nAction, nDirection)){
                    char szDirection[64];
                    std::sprintf(szDirection, "Direction: %d", nDirection);
                    m_browserDirection->add(szDirection, (void *)(uintptr_t)(nDirection));
                }
            }
        }
    }
    
    RedrawAll();
}}
        xywh {300 300 350 100} type Hold labelfont 4 textfont 4
      }
      Fl_Browser m_browserDirection {
        callback {{
    Fl::remove_timeout(TimeoutCallback);
    m_frame = -1;
    
    if(MonsterID() && Action() >= 0 && Direction() >= 0){
        extern AnimationDB g_animationDB;
        auto &rstRecord = g_animationDB.RetrieveAnimation(MonsterID());
        if(rstRecord.Valid() && rstRecord.DirectionValid(to_u32(Action()), to_u32(Direction()))){
            // ok we have a valid animation, reset it's frame index
            m_frame = 0;
            Fl::add_timeout(0.2, TimeoutCallback, nullptr);
        }
    }
    
    RedrawAll();
}}
        xywh {300 400 350 100} type Hold labelfont 4 textfont 4
      }
      Fl_Slider m_sliderR {
        label R
        xywh {300 280 350 20} type Horizontal labelfont 4 align 0 maximum 40 step 1 slider_size 0.1
      }
    }
  }
  Function {Load()} {return_type void
  } {
    code {{
    ClearAll();
    
    extern AnimationDB g_animationDB;
    size_t nSize = g_animationDB.Size();
    
    for(size_t nVID = 0; nVID < nSize; ++nVID){
        char szMonsterID[32];
        std::sprintf(szMonsterID, "Monster ID: %04d", g_animationDB.Get(nVID).MonsterID());
        
        m_browserAnimation->add(szMonsterID, (void *)(uintptr_t)(g_animationDB.Get(nVID).MonsterID()));
    }
}} {}
  }
  Function {HideAll()} {return_type void
  } {
    code {{
    m_window->hide();
}} {}
  }
  Function {ClearAll()} {return_type void
  } {
    code {{
    m_browserAnimation->clear();
    m_browserAction->clear();
    m_browserDirection->clear();
}} {}
  }
  Function {ShowAll()} {return_type void
  } {
    code {{
    m_window->show();
}} {}
  }
  Function {RedrawAll()} {return_type void
  } {
    code {{
    m_window->redraw();
}} {}
  }
  Function {MonsterID()} {return_type uint32_t
  } {
    code {{
    uint32_t nMonsterID = 0;
    
    for(int i = 1; i <= m_browserAnimation->size(); ++i){
        if(m_browserAnimation->selected(i)){
            nMonsterID = to_u32((uintptr_t)(m_browserAnimation->data(i)));
        }
    }
    
    return nMonsterID;
}} {}
  }
  Function {R()} {return_type int
  } {
    code {{
    if(!MonsterID()){ return -1; }
    return to_d(std::lround(m_sliderR->value()));
}} {}
  }
  Function {Action()} {return_type int
  } {
    code {{
    if(!MonsterID()){ return -1; }
    
    // we do have a valid monster id
    int nSelectedActionIndex = 0;
    for(int i = 1; i <= m_browserAction->size(); ++i){
        if(m_browserAction->selected(i)){
            nSelectedActionIndex = i;
            break;
        }
    }
     
    // we do select an action
    if(nSelectedActionIndex){
        return to_d((intptr_t)(m_browserAction->data(nSelectedActionIndex)));
    }
     
    return -1;
}} {}
  }
  Function {Direction()} {return_type int
  } {
    code {{
    if(!MonsterID()){ return -1; }
    if(Action() < 0){ return -1; }
    
    // we do have a valid monster id
    int nSelectedDirectionIndex = 0;
    for(int i = 1; i <= m_browserDirection->size(); ++i){
        if(m_browserDirection->selected(i)){
            nSelectedDirectionIndex = i;
            break;
        }
    }
     
    // we do select an action
    if(nSelectedDirectionIndex){
        return to_d((intptr_t)(m_browserDirection->data(nSelectedDirectionIndex)));
    }
     
    return -1;
}} {}
  }
  Function {Frame()} {return_type int
  } {
    code {{
    return m_frame;
}} {}
  }
  Function {TimeoutCallback(void *)} {return_type {static void}
  } {
    code {{
    extern AnimationSelectWindow *g_animationSelectWindow;
    if(true
        && g_animationSelectWindow->MonsterID()
        && g_animationSelectWindow->Action() >= 0
        && g_animationSelectWindow->Direction() >= 0){
        
        // ok currently we have a valid choice
        g_animationSelectWindow->UpdateFrame();
        Fl::repeat_timeout(0.2, TimeoutCallback, nullptr);
    }else{
        Fl::remove_timeout(TimeoutCallback);
    }

    g_animationSelectWindow->RedrawAll();
}} {}
  }
  Function {UpdateFrame()} {return_type void
  } {
    code {{
    if(MonsterID() && Action() >= 0 && Direction() >= 0){
        uint32_t nMonsterID = MonsterID();
        uint32_t nAction = to_u32(Action());
        uint32_t nDirection = to_u32(Direction());

        extern AnimationDB g_animationDB;
        auto &rstRecord = g_animationDB.RetrieveAnimation(nMonsterID);
        if(rstRecord.Valid() && rstRecord.DirectionValid(nAction, nDirection)){
            // we assume the frame is contingous, then if one frame is not ok, we just reset it to 0
            // this will also handle if current m_frame is -1
            if(rstRecord.FrameValid(nAction, nDirection, m_frame + 1, true) && rstRecord.FrameValid(nAction, nDirection, m_frame + 1, false)){
                m_frame = m_frame + 1;
            }else{
                m_frame = 0;
            }

            // done here
            return;
        }
    }

    // otherwise we set a error flag
    m_frame = -1;
}} {}
  }
}
