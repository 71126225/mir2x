# data file for the Fltk User Interface Designer (fluid)
version 1.0303 
header_name {.hpp} 
code_name {.cpp}
decl {\#include "taskhub.hpp"} {public global
} 

decl {\#include "commandinput.hpp"} {public global
} 

decl {\#include "serverluamodule.hpp"} {public global
} 

class CommandWindow {open
} {
  decl {TaskHub *m_LuaModuleTaskHub;} {private local
  }
  decl {ServerLuaModule *m_LuaModule;} {private local
  }
  Function {CommandWindow()} {} {
    Fl_Window m_Window {open
      xywh {757 211 580 400} type Double resizable visible
    } {
      Fl_Menu_Bar {} {
        xywh {0 0 580 25} box FLAT_BOX labelfont 4
      } {
        Submenu {} {
          label Configure open
          xywh {0 0 100 20} labelfont 4
        } {
          MenuItem {} {
            label Clear
            xywh {0 0 100 20} labelfont 4
          }
        }
      }
      Fl_Input m_Input {
        xywh {0 375 580 25} labeltype NO_LABEL labelfont 4 textfont 4 resizable
        class CommandInput
      }
      Fl_Browser m_Browser {
        xywh {0 25 580 350} type Hold labelfont 4 textfont 4
      }
    }
    code {{
    // initialization of the lua module and its taskhub
	m_LuaModule        = nullptr;
    m_LuaModuleTaskHub = nullptr;
	
	// bind current window to CommandInput
	// which helps to do event logic handling inside CommandInput
	// avoid to do it in CommandWindow::handle(int)
	m_Input->Bind(this);
}} {}
  }
  Function {HideAll()} {return_type void
  } {
    code {{
	m_Window->hide();
}} {}
  }
  Function {ShowAll()} {return_type void
  } {
    code {{
	m_Window->show();
}} {}
  }
  Function {GetTaskHub()} {return_type {TaskHub *}
  } {
    code {{
	// won't put any cv-qualifiers
	// expose the TaskHub interface to outside
	return m_LuaModuleTaskHub;
}} {}
  }
  Function {GetLuaModule()} {return_type {ServerLuaModule *}
  } {
    code {{
	// won't put any cv-qualifiers
	// expose the TaskHub interface to outside
	// then I don't have do implement CommandWindow::Execute(const char *)
	return m_LuaModule;
}} {}
  }
  Function {DetachLuaModule()} {return_type void
  } {
    code {{
	// won't put any cv-qualifiers
	// expose the TaskHub interface to outside
	// then I don't have do implement CommandWindow::Execute(const char *)
    delete m_LuaModule;        m_LuaModule        = nullptr;
    delete m_LuaModuleTaskHub; m_LuaModuleTaskHub = nullptr;
}} {}
  }
  Function {BindLuaModule(int nCWID)} {return_type void
  } {
    code {{
    // activate the internal LuaModule and its TaskHub
    // after this line the LuaModule grants a CWID to print
    // and LuaModuleTaskHub has an LuaModule as command input
    {
        if(nCWID > 0){
            assert(m_LuaModule        == nullptr);
            assert(m_LuaModuleTaskHub == nullptr);

            m_LuaModule        = new ServerLuaModule((uint32_t)(nCWID));
            m_LuaModuleTaskHub = new TaskHub();

            // start the hub now
            m_LuaModuleTaskHub->Launch();
        }
    }
}} {}
  }
  Function {AddLog(int nLogType, const char *szPrompt, const char *szLogInfo)} {selected return_type void
  } {
    code {{
    // log can be multiply lines but only do one line for this call
    // don't put multi-thread handling code here

    if(m_Browser->size() > 5000){
        m_Browser->remove(1);
    }

    const char *pColorCode = nullptr;
    switch(nLogType){
        case 0  : pColorCode = "@C4"; break;
        case 1  : pColorCode = "@C9"; break;
        default : pColorCode = "@C1"; break;
    }

    m_Browser->add(((std::string(pColorCode) + (szPrompt ? szPrompt : "")) + (szLogInfo ? szLogInfo : "")).c_str());
    m_Browser->bottomline(m_Browser->size());
}} {}
  }
} 
